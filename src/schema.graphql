### This file was autogenerated by GraphQL Nexus
### Do not make changes to this file directly


"""DateTime"""
scalar DateTime

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

type Mutation {
  clockcodetouser(code: Int): User!
  createPunchCard(data: PunchCardCreateInput!): PunchCard!
  createTimeCard(data: TimeCardCreateInput!): TimeCard!
  createTimeRole(data: TimeRoleCreateInput!): TimeRole!
  createUser(code: Int!, email: String!, firstName: String!, lastName: String!, password: String!, title: String): User!
  deletePunchCard(where: PunchCardWhereUniqueInput!): PunchCard
  deleteTimeCard(where: TimeCardWhereUniqueInput!): TimeCard
  deleteTimeRole(id: ID): TimeRole!
  deleteUser(where: UserWhereUniqueInput!): User
  resetPassword(id: ID, password: String): User!
  signin(email: String, password: String): User!
  signout: String!
  updatePunchCard(data: PunchCardUpdateInput!, where: PunchCardWhereUniqueInput!): PunchCard
  updateTimeCard(data: TimeCardUpdateInput!, where: TimeCardWhereUniqueInput!): TimeCard
  updateTimeRole(data: TimeRoleUpdateInput!, where: TimeRoleWhereUniqueInput!): TimeRole
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
}

input MutationUpdateOneTimeRoleFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input MutationUpdateOneTimeRoleWhereInput {
  AND: [MutationUpdateOneTimeRoleWhereInput!]
  code: IntFilter
  createdAt: MutationUpdateOneTimeRoleFilter
  email: StringFilter
  firstName: StringFilter
  id: StringFilter
  lastName: StringFilter
  NOT: [MutationUpdateOneTimeRoleWhereInput!]
  OR: [MutationUpdateOneTimeRoleWhereInput!]
  password: StringFilter
  punchCards: MutationUpdateOneTimeRoleFilter
  timeCards: MutationUpdateOneTimeRoleFilter
  timeRoles: MutationUpdateOneTimeRoleFilter
  title: NullableStringFilter
  updatedAt: MutationUpdateOneTimeRoleFilter
}

input MutationUpdateOneUserFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input MutationUpdateOneUserWhereInput {
  AND: [MutationUpdateOneUserWhereInput!]
  createdAt: MutationUpdateOneUserFilter
  id: StringFilter
  NOT: [MutationUpdateOneUserWhereInput!]
  OR: [MutationUpdateOneUserWhereInput!]
  punchTime: MutationUpdateOneUserFilter
  punchType: MutationUpdateOneUserFilter
  updatedAt: MutationUpdateOneUserFilter
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

enum OrderByArg {
  asc
  desc
}

enum Permissions {
  ADMIN
  TIMECARDEDITOR
  TIMECARDVIEWER
  USER
}

type PunchCard {
  createdAt: DateTime!
  id: ID!
  punchIn: DateTime!
  punchOut: DateTime!
  timeRole: TimeRole!
  updatedAt: DateTime!
  user: User!
}

input PunchCardCreateInput {
  createdAt: DateTime
  id: ID
  punchIn: DateTime!
  punchOut: DateTime!
  timeRole: TimeRoleCreateOneWithoutTimeRoleInput!
  updatedAt: DateTime
  user: UserCreateOneWithoutUserInput!
}

input PunchCardCreateManyWithoutPunchCardsInput {
  connect: [PunchCardWhereUniqueInput!]
  create: [PunchCardCreateWithoutUserInput!]
}

input PunchCardCreateWithoutTimeRoleInput {
  createdAt: DateTime
  id: ID
  punchIn: DateTime!
  punchOut: DateTime!
  updatedAt: DateTime
  user: UserCreateOneWithoutUserInput!
}

input PunchCardCreateWithoutUserInput {
  createdAt: DateTime
  id: ID
  punchIn: DateTime!
  punchOut: DateTime!
  timeRole: TimeRoleCreateOneWithoutTimeRoleInput!
  updatedAt: DateTime
}

input PunchCardUpdateInput {
  createdAt: DateTime
  id: ID
  punchIn: DateTime
  punchOut: DateTime
  timeRole: TimeRoleUpdateOneRequiredWithoutPunchCardsInput
  updatedAt: DateTime
  user: UserUpdateOneRequiredWithoutPunchCardsInput
}

input PunchCardUpdateManyDataInput {
  createdAt: DateTime
  id: ID
  punchIn: DateTime
  punchOut: DateTime
  updatedAt: DateTime
}

input PunchCardUpdateManyWithoutTimeRoleInput {
  connect: [PunchCardWhereUniqueInput!]
  create: [PunchCardCreateWithoutTimeRoleInput!]
  delete: [PunchCardWhereUniqueInput!]
  deleteMany: [MutationUpdateOneTimeRoleWhereInput!]
  disconnect: [PunchCardWhereUniqueInput!]
  set: [PunchCardWhereUniqueInput!]
  update: [PunchCardUpdateWithWhereUniqueWithoutTimeRoleInput!]
  updateMany: [PunchCardUpdateManyWithWhereNestedInput!]
  upsert: [PunchCardUpsertWithWhereUniqueWithoutTimeRoleInput!]
}

input PunchCardUpdateManyWithoutUserInput {
  connect: [PunchCardWhereUniqueInput!]
  create: [PunchCardCreateWithoutUserInput!]
  delete: [PunchCardWhereUniqueInput!]
  deleteMany: [MutationUpdateOneUserWhereInput!]
  disconnect: [PunchCardWhereUniqueInput!]
  set: [PunchCardWhereUniqueInput!]
  update: [PunchCardUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [PunchCardUpdateManyWithWhereNestedInput!]
  upsert: [PunchCardUpsertWithWhereUniqueWithoutUserInput!]
}

input PunchCardUpdateManyWithWhereNestedInput {
  data: PunchCardUpdateManyDataInput!
  where: MutationUpdateOneUserWhereInput!
}

input PunchCardUpdateWithoutTimeRoleDataInput {
  createdAt: DateTime
  id: ID
  punchIn: DateTime
  punchOut: DateTime
  updatedAt: DateTime
  user: UserUpdateOneRequiredWithoutPunchCardsInput
}

input PunchCardUpdateWithoutUserDataInput {
  createdAt: DateTime
  id: ID
  punchIn: DateTime
  punchOut: DateTime
  timeRole: TimeRoleUpdateOneRequiredWithoutPunchCardsInput
  updatedAt: DateTime
}

input PunchCardUpdateWithWhereUniqueWithoutTimeRoleInput {
  data: PunchCardUpdateWithoutTimeRoleDataInput!
  where: PunchCardWhereUniqueInput!
}

input PunchCardUpdateWithWhereUniqueWithoutUserInput {
  data: PunchCardUpdateWithoutUserDataInput!
  where: PunchCardWhereUniqueInput!
}

input PunchCardUpsertWithWhereUniqueWithoutTimeRoleInput {
  create: PunchCardCreateWithoutTimeRoleInput!
  update: PunchCardUpdateWithoutTimeRoleDataInput!
  where: PunchCardWhereUniqueInput!
}

input PunchCardUpsertWithWhereUniqueWithoutUserInput {
  create: PunchCardCreateWithoutUserInput!
  update: PunchCardUpdateWithoutUserDataInput!
  where: PunchCardWhereUniqueInput!
}

input PunchCardWhereUniqueInput {
  id: ID
}

enum Punchtype {
  CLOCKIN
  CLOCKOUT
}

type Query {
  me: User
  punchCard(where: PunchCardWhereUniqueInput!): PunchCard
  punchCards(after: String, before: String, first: Int, last: Int, orderBy: QueryFindManyPunchCardOrderByInput, skip: Int, where: QueryFindManyPunchCardWhereInput): [PunchCard!]
  test: [String!]!
  timeCards(after: String, before: String, first: Int, last: Int, orderBy: QueryFindManyTimeCardOrderByInput, skip: Int, where: QueryFindManyTimeCardWhereInput): [TimeCard!]
  timeRoles(after: String, before: String, first: Int, last: Int, orderBy: QueryFindManyTimeRoleOrderByInput, skip: Int, where: QueryFindManyTimeRoleWhereInput): [TimeRole!]
  users(after: String, before: String, first: Int, last: Int, orderBy: QueryFindManyUserOrderByInput, skip: Int, where: QueryFindManyUserWhereInput): [User!]
}

input QueryFindManyPunchCardFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input QueryFindManyPunchCardOrderByInput {
  createdAt: OrderByArg
  id: OrderByArg
  punchIn: OrderByArg
  punchOut: OrderByArg
  updatedAt: OrderByArg
}

input QueryFindManyPunchCardWhereInput {
  AND: [QueryFindManyPunchCardWhereInput!]
  createdAt: QueryFindManyPunchCardFilter
  id: StringFilter
  NOT: [QueryFindManyPunchCardWhereInput!]
  OR: [QueryFindManyPunchCardWhereInput!]
  punchIn: QueryFindManyPunchCardFilter
  punchOut: QueryFindManyPunchCardFilter
  timeRole: QueryFindManyPunchCardWhereInput
  updatedAt: QueryFindManyPunchCardFilter
  user: QueryFindManyPunchCardWhereInput
}

input QueryFindManyTimeCardFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input QueryFindManyTimeCardOrderByInput {
  createdAt: OrderByArg
  id: OrderByArg
  punchTime: OrderByArg
  punchType: OrderByArg
  updatedAt: OrderByArg
}

input QueryFindManyTimeCardWhereInput {
  AND: [QueryFindManyTimeCardWhereInput!]
  createdAt: QueryFindManyTimeCardFilter
  id: StringFilter
  NOT: [QueryFindManyTimeCardWhereInput!]
  OR: [QueryFindManyTimeCardWhereInput!]
  punchTime: QueryFindManyTimeCardFilter
  punchType: QueryFindManyTimeCardFilter
  timeRole: QueryFindManyTimeCardWhereInput
  updatedAt: QueryFindManyTimeCardFilter
  user: QueryFindManyTimeCardWhereInput
}

input QueryFindManyTimeRoleFilter {
  every: QueryFindManyTimeRoleWhereInput
  none: QueryFindManyTimeRoleWhereInput
  some: QueryFindManyTimeRoleWhereInput
}

input QueryFindManyTimeRoleOrderByInput {
  createdAt: OrderByArg
  description: OrderByArg
  id: OrderByArg
  name: OrderByArg
  payRate: OrderByArg
  shortName: OrderByArg
  updatedAt: OrderByArg
}

input QueryFindManyTimeRoleWhereInput {
  AND: [QueryFindManyTimeRoleWhereInput!]
  createdAt: QueryFindManyTimeRoleFilter
  description: StringFilter
  id: StringFilter
  name: StringFilter
  NOT: [QueryFindManyTimeRoleWhereInput!]
  OR: [QueryFindManyTimeRoleWhereInput!]
  payRate: IntFilter
  punchCards: QueryFindManyTimeRoleFilter
  shortName: StringFilter
  timeCards: QueryFindManyTimeRoleFilter
  updatedAt: QueryFindManyTimeRoleFilter
  users: QueryFindManyTimeRoleFilter
}

input QueryFindManyUserFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input QueryFindManyUserOrderByInput {
  code: OrderByArg
  createdAt: OrderByArg
  email: OrderByArg
  firstName: OrderByArg
  id: OrderByArg
  lastName: OrderByArg
  password: OrderByArg
  title: OrderByArg
  updatedAt: OrderByArg
}

input QueryFindManyUserWhereInput {
  AND: [QueryFindManyUserWhereInput!]
  code: IntFilter
  createdAt: QueryFindManyUserFilter
  email: StringFilter
  firstName: StringFilter
  id: StringFilter
  lastName: StringFilter
  NOT: [QueryFindManyUserWhereInput!]
  OR: [QueryFindManyUserWhereInput!]
  password: StringFilter
  punchCards: QueryFindManyUserFilter
  timeCards: QueryFindManyUserFilter
  timeRoles: QueryFindManyUserFilter
  title: NullableStringFilter
  updatedAt: QueryFindManyUserFilter
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type TimeCard {
  createdAt: DateTime!
  id: ID!
  punchTime: DateTime!
  punchType: Punchtype!
  timeRole: TimeRole!
  updatedAt: DateTime!
  user: User!
}

input TimeCardCreateInput {
  createdAt: DateTime
  id: ID
  punchTime: DateTime!
  punchType: Punchtype!
  timeRole: TimeRoleCreateOneWithoutTimeRoleInput!
  updatedAt: DateTime
  user: UserCreateOneWithoutUserInput!
}

input TimeCardCreateManyWithoutTimeCardsInput {
  connect: [TimeCardWhereUniqueInput!]
  create: [TimeCardCreateWithoutUserInput!]
}

input TimeCardCreateWithoutTimeRoleInput {
  createdAt: DateTime
  id: ID
  punchTime: DateTime!
  punchType: Punchtype!
  updatedAt: DateTime
  user: UserCreateOneWithoutUserInput!
}

input TimeCardCreateWithoutUserInput {
  createdAt: DateTime
  id: ID
  punchTime: DateTime!
  punchType: Punchtype!
  timeRole: TimeRoleCreateOneWithoutTimeRoleInput!
  updatedAt: DateTime
}

input TimeCardUpdateInput {
  createdAt: DateTime
  id: ID
  punchTime: DateTime
  punchType: Punchtype
  timeRole: TimeRoleUpdateOneRequiredWithoutTimeCardsInput
  updatedAt: DateTime
  user: UserUpdateOneRequiredWithoutTimeCardsInput
}

input TimeCardUpdateManyDataInput {
  createdAt: DateTime
  id: ID
  punchTime: DateTime
  punchType: Punchtype
  updatedAt: DateTime
}

input TimeCardUpdateManyWithoutTimeRoleInput {
  connect: [TimeCardWhereUniqueInput!]
  create: [TimeCardCreateWithoutTimeRoleInput!]
  delete: [TimeCardWhereUniqueInput!]
  deleteMany: [MutationUpdateOneTimeRoleWhereInput!]
  disconnect: [TimeCardWhereUniqueInput!]
  set: [TimeCardWhereUniqueInput!]
  update: [TimeCardUpdateWithWhereUniqueWithoutTimeRoleInput!]
  updateMany: [TimeCardUpdateManyWithWhereNestedInput!]
  upsert: [TimeCardUpsertWithWhereUniqueWithoutTimeRoleInput!]
}

input TimeCardUpdateManyWithoutUserInput {
  connect: [TimeCardWhereUniqueInput!]
  create: [TimeCardCreateWithoutUserInput!]
  delete: [TimeCardWhereUniqueInput!]
  deleteMany: [MutationUpdateOneUserWhereInput!]
  disconnect: [TimeCardWhereUniqueInput!]
  set: [TimeCardWhereUniqueInput!]
  update: [TimeCardUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [TimeCardUpdateManyWithWhereNestedInput!]
  upsert: [TimeCardUpsertWithWhereUniqueWithoutUserInput!]
}

input TimeCardUpdateManyWithWhereNestedInput {
  data: TimeCardUpdateManyDataInput!
  where: MutationUpdateOneUserWhereInput!
}

input TimeCardUpdateWithoutTimeRoleDataInput {
  createdAt: DateTime
  id: ID
  punchTime: DateTime
  punchType: Punchtype
  updatedAt: DateTime
  user: UserUpdateOneRequiredWithoutTimeCardsInput
}

input TimeCardUpdateWithoutUserDataInput {
  createdAt: DateTime
  id: ID
  punchTime: DateTime
  punchType: Punchtype
  timeRole: TimeRoleUpdateOneRequiredWithoutTimeCardsInput
  updatedAt: DateTime
}

input TimeCardUpdateWithWhereUniqueWithoutTimeRoleInput {
  data: TimeCardUpdateWithoutTimeRoleDataInput!
  where: TimeCardWhereUniqueInput!
}

input TimeCardUpdateWithWhereUniqueWithoutUserInput {
  data: TimeCardUpdateWithoutUserDataInput!
  where: TimeCardWhereUniqueInput!
}

input TimeCardUpsertWithWhereUniqueWithoutTimeRoleInput {
  create: TimeCardCreateWithoutTimeRoleInput!
  update: TimeCardUpdateWithoutTimeRoleDataInput!
  where: TimeCardWhereUniqueInput!
}

input TimeCardUpsertWithWhereUniqueWithoutUserInput {
  create: TimeCardCreateWithoutUserInput!
  update: TimeCardUpdateWithoutUserDataInput!
  where: TimeCardWhereUniqueInput!
}

input TimeCardWhereUniqueInput {
  id: ID
}

type TimeRole {
  createdAt: DateTime!
  description: String!
  id: ID!
  name: String!
  payRate: Int!
  shortName: String!
  updatedAt: DateTime!
  users(after: String, before: String, first: Int, last: Int, skip: Int): [User!]
}

input TimeRoleCreateInput {
  createdAt: DateTime
  description: String!
  id: ID
  name: String!
  payRate: Int!
  punchCards: PunchCardCreateManyWithoutPunchCardsInput
  shortName: String!
  timeCards: TimeCardCreateManyWithoutTimeCardsInput
  updatedAt: DateTime
  users: UserCreateManyWithoutUsersInput
}

input TimeRoleCreateManyWithoutTimeRolesInput {
  connect: [TimeRoleWhereUniqueInput!]
  create: [TimeRoleCreateWithoutUsersInput!]
}

input TimeRoleCreateOneWithoutTimeRoleInput {
  connect: TimeRoleWhereUniqueInput
  create: TimeRoleCreateWithoutTimeCardsInput
}

input TimeRoleCreateWithoutPunchCardsInput {
  createdAt: DateTime
  description: String!
  id: ID
  name: String!
  payRate: Int!
  shortName: String!
  timeCards: TimeCardCreateManyWithoutTimeCardsInput
  updatedAt: DateTime
  users: UserCreateManyWithoutUsersInput
}

input TimeRoleCreateWithoutTimeCardsInput {
  createdAt: DateTime
  description: String!
  id: ID
  name: String!
  payRate: Int!
  punchCards: PunchCardCreateManyWithoutPunchCardsInput
  shortName: String!
  updatedAt: DateTime
  users: UserCreateManyWithoutUsersInput
}

input TimeRoleCreateWithoutUsersInput {
  createdAt: DateTime
  description: String!
  id: ID
  name: String!
  payRate: Int!
  punchCards: PunchCardCreateManyWithoutPunchCardsInput
  shortName: String!
  timeCards: TimeCardCreateManyWithoutTimeCardsInput
  updatedAt: DateTime
}

input TimeRoleUpdateInput {
  createdAt: DateTime
  description: String
  id: ID
  name: String
  payRate: Int
  punchCards: PunchCardUpdateManyWithoutTimeRoleInput
  shortName: String
  timeCards: TimeCardUpdateManyWithoutTimeRoleInput
  updatedAt: DateTime
  users: UserUpdateManyWithoutTimeRolesInput
}

input TimeRoleUpdateManyDataInput {
  createdAt: DateTime
  description: String
  id: ID
  name: String
  payRate: Int
  shortName: String
  updatedAt: DateTime
}

input TimeRoleUpdateManyWithoutUsersInput {
  connect: [TimeRoleWhereUniqueInput!]
  create: [TimeRoleCreateWithoutUsersInput!]
  delete: [TimeRoleWhereUniqueInput!]
  deleteMany: [MutationUpdateOneUserWhereInput!]
  disconnect: [TimeRoleWhereUniqueInput!]
  set: [TimeRoleWhereUniqueInput!]
  update: [TimeRoleUpdateWithWhereUniqueWithoutUsersInput!]
  updateMany: [TimeRoleUpdateManyWithWhereNestedInput!]
  upsert: [TimeRoleUpsertWithWhereUniqueWithoutUsersInput!]
}

input TimeRoleUpdateManyWithWhereNestedInput {
  data: TimeRoleUpdateManyDataInput!
  where: MutationUpdateOneUserWhereInput!
}

input TimeRoleUpdateOneRequiredWithoutPunchCardsInput {
  connect: TimeRoleWhereUniqueInput
  create: TimeRoleCreateWithoutPunchCardsInput
  update: TimeRoleUpdateWithoutPunchCardsDataInput
  upsert: TimeRoleUpsertWithoutPunchCardsInput
}

input TimeRoleUpdateOneRequiredWithoutTimeCardsInput {
  connect: TimeRoleWhereUniqueInput
  create: TimeRoleCreateWithoutTimeCardsInput
  update: TimeRoleUpdateWithoutTimeCardsDataInput
  upsert: TimeRoleUpsertWithoutTimeCardsInput
}

input TimeRoleUpdateWithoutPunchCardsDataInput {
  createdAt: DateTime
  description: String
  id: ID
  name: String
  payRate: Int
  shortName: String
  timeCards: TimeCardUpdateManyWithoutTimeRoleInput
  updatedAt: DateTime
  users: UserUpdateManyWithoutTimeRolesInput
}

input TimeRoleUpdateWithoutTimeCardsDataInput {
  createdAt: DateTime
  description: String
  id: ID
  name: String
  payRate: Int
  punchCards: PunchCardUpdateManyWithoutTimeRoleInput
  shortName: String
  updatedAt: DateTime
  users: UserUpdateManyWithoutTimeRolesInput
}

input TimeRoleUpdateWithoutUsersDataInput {
  createdAt: DateTime
  description: String
  id: ID
  name: String
  payRate: Int
  punchCards: PunchCardUpdateManyWithoutTimeRoleInput
  shortName: String
  timeCards: TimeCardUpdateManyWithoutTimeRoleInput
  updatedAt: DateTime
}

input TimeRoleUpdateWithWhereUniqueWithoutUsersInput {
  data: TimeRoleUpdateWithoutUsersDataInput!
  where: TimeRoleWhereUniqueInput!
}

input TimeRoleUpsertWithoutPunchCardsInput {
  create: TimeRoleCreateWithoutPunchCardsInput!
  update: TimeRoleUpdateWithoutPunchCardsDataInput!
}

input TimeRoleUpsertWithoutTimeCardsInput {
  create: TimeRoleCreateWithoutTimeCardsInput!
  update: TimeRoleUpdateWithoutTimeCardsDataInput!
}

input TimeRoleUpsertWithWhereUniqueWithoutUsersInput {
  create: TimeRoleCreateWithoutUsersInput!
  update: TimeRoleUpdateWithoutUsersDataInput!
  where: TimeRoleWhereUniqueInput!
}

input TimeRoleWhereUniqueInput {
  id: ID
}

type User {
  clockedIn: String!
  code: Int!
  createdAt: DateTime!
  email: String!
  firstName: String!
  id: ID!
  lastName: String!
  permissions: [Permissions!]!
  recentTimeRoleId: String!
  timeCards(after: String, before: String, first: Int, last: Int, orderBy: UserTimeCardsOrderByInput, skip: Int): [TimeCard!]
  timeRoles(after: String, before: String, first: Int, last: Int, skip: Int): [TimeRole!]
  title: String
  updatedAt: DateTime!
}

input UserCreateManyWithoutUsersInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutTimeRolesInput!]
}

input UserCreateOneWithoutUserInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutTimeCardsInput
}

input UserCreatepermissionsInput {
  set: [Permissions!]
}

input UserCreateWithoutPunchCardsInput {
  code: Int!
  createdAt: DateTime
  email: String!
  firstName: String!
  id: ID
  lastName: String!
  password: String!
  permissions: UserCreatepermissionsInput
  timeCards: TimeCardCreateManyWithoutTimeCardsInput
  timeRoles: TimeRoleCreateManyWithoutTimeRolesInput
  title: String
  updatedAt: DateTime
}

input UserCreateWithoutTimeCardsInput {
  code: Int!
  createdAt: DateTime
  email: String!
  firstName: String!
  id: ID
  lastName: String!
  password: String!
  permissions: UserCreatepermissionsInput
  punchCards: PunchCardCreateManyWithoutPunchCardsInput
  timeRoles: TimeRoleCreateManyWithoutTimeRolesInput
  title: String
  updatedAt: DateTime
}

input UserCreateWithoutTimeRolesInput {
  code: Int!
  createdAt: DateTime
  email: String!
  firstName: String!
  id: ID
  lastName: String!
  password: String!
  permissions: UserCreatepermissionsInput
  punchCards: PunchCardCreateManyWithoutPunchCardsInput
  timeCards: TimeCardCreateManyWithoutTimeCardsInput
  title: String
  updatedAt: DateTime
}

input UserTimeCardsOrderByInput {
  createdAt: OrderByArg
  id: OrderByArg
  punchTime: OrderByArg
  punchType: OrderByArg
  updatedAt: OrderByArg
}

input UserUpdateInput {
  code: Int
  createdAt: DateTime
  email: String
  firstName: String
  id: ID
  lastName: String
  password: String
  permissions: UserUpdatepermissionsInput
  punchCards: PunchCardUpdateManyWithoutUserInput
  timeCards: TimeCardUpdateManyWithoutUserInput
  timeRoles: TimeRoleUpdateManyWithoutUsersInput
  title: String
  updatedAt: DateTime
}

input UserUpdateManyDataInput {
  code: Int
  createdAt: DateTime
  email: String
  firstName: String
  id: ID
  lastName: String
  password: String
  permissions: UserUpdatepermissionsInput
  title: String
  updatedAt: DateTime
}

input UserUpdateManyWithoutTimeRolesInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutTimeRolesInput!]
  delete: [UserWhereUniqueInput!]
  deleteMany: [MutationUpdateOneTimeRoleWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutTimeRolesInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutTimeRolesInput!]
}

input UserUpdateManyWithWhereNestedInput {
  data: UserUpdateManyDataInput!
  where: MutationUpdateOneTimeRoleWhereInput!
}

input UserUpdateOneRequiredWithoutPunchCardsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutPunchCardsInput
  update: UserUpdateWithoutPunchCardsDataInput
  upsert: UserUpsertWithoutPunchCardsInput
}

input UserUpdateOneRequiredWithoutTimeCardsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutTimeCardsInput
  update: UserUpdateWithoutTimeCardsDataInput
  upsert: UserUpsertWithoutTimeCardsInput
}

input UserUpdatepermissionsInput {
  set: [Permissions!]
}

input UserUpdateWithoutPunchCardsDataInput {
  code: Int
  createdAt: DateTime
  email: String
  firstName: String
  id: ID
  lastName: String
  password: String
  permissions: UserUpdatepermissionsInput
  timeCards: TimeCardUpdateManyWithoutUserInput
  timeRoles: TimeRoleUpdateManyWithoutUsersInput
  title: String
  updatedAt: DateTime
}

input UserUpdateWithoutTimeCardsDataInput {
  code: Int
  createdAt: DateTime
  email: String
  firstName: String
  id: ID
  lastName: String
  password: String
  permissions: UserUpdatepermissionsInput
  punchCards: PunchCardUpdateManyWithoutUserInput
  timeRoles: TimeRoleUpdateManyWithoutUsersInput
  title: String
  updatedAt: DateTime
}

input UserUpdateWithoutTimeRolesDataInput {
  code: Int
  createdAt: DateTime
  email: String
  firstName: String
  id: ID
  lastName: String
  password: String
  permissions: UserUpdatepermissionsInput
  punchCards: PunchCardUpdateManyWithoutUserInput
  timeCards: TimeCardUpdateManyWithoutUserInput
  title: String
  updatedAt: DateTime
}

input UserUpdateWithWhereUniqueWithoutTimeRolesInput {
  data: UserUpdateWithoutTimeRolesDataInput!
  where: UserWhereUniqueInput!
}

input UserUpsertWithoutPunchCardsInput {
  create: UserCreateWithoutPunchCardsInput!
  update: UserUpdateWithoutPunchCardsDataInput!
}

input UserUpsertWithoutTimeCardsInput {
  create: UserCreateWithoutTimeCardsInput!
  update: UserUpdateWithoutTimeCardsDataInput!
}

input UserUpsertWithWhereUniqueWithoutTimeRolesInput {
  create: UserCreateWithoutTimeRolesInput!
  update: UserUpdateWithoutTimeRolesDataInput!
  where: UserWhereUniqueInput!
}

input UserWhereUniqueInput {
  code: Int
  email: String
  id: ID
}
