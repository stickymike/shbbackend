### This file was autogenerated by GraphQL Nexus
### Do not make changes to this file directly


input BooleanFilter {
  equals: Boolean
  not: Boolean
}

scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: Float
  notIn: [Float!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

type Mutation {
  clockcodetouser(code: Int): User!
  createOneTask(data: TaskCreateInput!): Task!
  createOneTaskList(data: TaskListCreateInput!): TaskList!
  createPunchCard(data: PunchCardCreateInput!): PunchCard!
  createTimeRequest(data: TimeRequestCreateInput!): TimeRequest!
  createTimeRole(data: TimeRoleCreateInput!): TimeRole!
  createUser(code: Int!, email: String!, firstName: String!, lastName: String!, password: String!, title: String): User!
  deleteOneTask(where: TaskWhereUniqueInput!): Task
  deleteOneTaskList(where: TaskListWhereUniqueInput!): TaskList
  deletePunchCard(where: PunchCardWhereUniqueInput!): PunchCard
  deleteTimeRequest(where: TimeRequestWhereUniqueInput!): TimeRequest
  deleteTimeRole(id: ID): TimeRole!
  deleteUser(where: UserWhereUniqueInput!): User
  resetPassword(id: ID, password: String): User!
  signin(email: String, password: String): User!
  signout: String!
  updateOneTask(data: TaskUpdateInput!, where: TaskWhereUniqueInput!): Task
  updateOneTaskList(data: TaskListUpdateInput!, where: TaskListWhereUniqueInput!): TaskList
  updatePunchCard(data: PunchCardUpdateInput!, where: PunchCardWhereUniqueInput!): PunchCard
  updateTimeRequest(data: TimeRequestUpdateInput!, where: TimeRequestWhereUniqueInput!): TimeRequest
  updateTimeRole(data: TimeRoleUpdateInput!, where: TimeRoleWhereUniqueInput!): TimeRole
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
}

input NullableBooleanFilter {
  equals: Boolean
  not: Boolean
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

enum OrderByArg {
  asc
  desc
}

enum Permission {
  ADMIN
  TIMECARDEDITOR
  TIMECARDVIEWER
  USER
}

type PunchCard {
  createdAt: DateTime!
  id: String!
  punchIn: DateTime!
  punchOut: DateTime!
  timeRole: TimeRole!
  updatedAt: DateTime!
  user: User!
}

input PunchCardCreateInput {
  createdAt: DateTime
  id: String
  punchIn: DateTime!
  punchOut: DateTime!
  timeRole: TimeRoleCreateOneWithoutPunchCardsInput!
  updatedAt: DateTime
  user: UserCreateOneWithoutPunchCardsInput!
  userID: String!
}

input PunchCardCreateManyWithoutTimeRoleInput {
  connect: [PunchCardWhereUniqueInput!]
  create: [PunchCardCreateWithoutTimeRoleInput!]
}

input PunchCardCreateManyWithoutUserInput {
  connect: [PunchCardWhereUniqueInput!]
  create: [PunchCardCreateWithoutUserInput!]
}

input PunchCardCreateWithoutTimeRoleInput {
  createdAt: DateTime
  id: String
  punchIn: DateTime!
  punchOut: DateTime!
  updatedAt: DateTime
  user: UserCreateOneWithoutPunchCardsInput!
  userID: String!
}

input PunchCardCreateWithoutUserInput {
  createdAt: DateTime
  id: String
  punchIn: DateTime!
  punchOut: DateTime!
  timeRole: TimeRoleCreateOneWithoutPunchCardsInput!
  updatedAt: DateTime
  userID: String!
}

input PunchCardFilter {
  every: PunchCardWhereInput
  none: PunchCardWhereInput
  some: PunchCardWhereInput
}

input PunchCardOrderByInput {
  createdAt: OrderByArg
  id: OrderByArg
  punchIn: OrderByArg
  punchOut: OrderByArg
  timeRole: OrderByArg
  timeRoleId: OrderByArg
  updatedAt: OrderByArg
  user: OrderByArg
  userId: OrderByArg
  userID: OrderByArg
}

input PunchCardScalarWhereInput {
  AND: [PunchCardScalarWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [PunchCardScalarWhereInput!]
  OR: [PunchCardScalarWhereInput!]
  punchIn: DateTimeFilter
  punchOut: DateTimeFilter
  timeRoleId: StringFilter
  updatedAt: DateTimeFilter
  userId: StringFilter
  userID: StringFilter
}

input PunchCardUpdateInput {
  createdAt: DateTime
  id: String
  punchIn: DateTime
  punchOut: DateTime
  timeRole: TimeRoleUpdateOneRequiredWithoutPunchCardsInput
  updatedAt: DateTime
  user: UserUpdateOneRequiredWithoutPunchCardsInput
  userID: String
}

input PunchCardUpdateManyDataInput {
  createdAt: DateTime
  id: String
  punchIn: DateTime
  punchOut: DateTime
  updatedAt: DateTime
  userID: String
}

input PunchCardUpdateManyWithoutTimeRoleInput {
  connect: [PunchCardWhereUniqueInput!]
  create: [PunchCardCreateWithoutTimeRoleInput!]
  delete: [PunchCardWhereUniqueInput!]
  deleteMany: [PunchCardScalarWhereInput!]
  disconnect: [PunchCardWhereUniqueInput!]
  set: [PunchCardWhereUniqueInput!]
  update: [PunchCardUpdateWithWhereUniqueWithoutTimeRoleInput!]
  updateMany: [PunchCardUpdateManyWithWhereNestedInput!]
  upsert: [PunchCardUpsertWithWhereUniqueWithoutTimeRoleInput!]
}

input PunchCardUpdateManyWithoutUserInput {
  connect: [PunchCardWhereUniqueInput!]
  create: [PunchCardCreateWithoutUserInput!]
  delete: [PunchCardWhereUniqueInput!]
  deleteMany: [PunchCardScalarWhereInput!]
  disconnect: [PunchCardWhereUniqueInput!]
  set: [PunchCardWhereUniqueInput!]
  update: [PunchCardUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [PunchCardUpdateManyWithWhereNestedInput!]
  upsert: [PunchCardUpsertWithWhereUniqueWithoutUserInput!]
}

input PunchCardUpdateManyWithWhereNestedInput {
  data: PunchCardUpdateManyDataInput!
  where: PunchCardScalarWhereInput!
}

input PunchCardUpdateWithoutTimeRoleDataInput {
  createdAt: DateTime
  id: String
  punchIn: DateTime
  punchOut: DateTime
  updatedAt: DateTime
  user: UserUpdateOneRequiredWithoutPunchCardsInput
  userID: String
}

input PunchCardUpdateWithoutUserDataInput {
  createdAt: DateTime
  id: String
  punchIn: DateTime
  punchOut: DateTime
  timeRole: TimeRoleUpdateOneRequiredWithoutPunchCardsInput
  updatedAt: DateTime
  userID: String
}

input PunchCardUpdateWithWhereUniqueWithoutTimeRoleInput {
  data: PunchCardUpdateWithoutTimeRoleDataInput!
  where: PunchCardWhereUniqueInput!
}

input PunchCardUpdateWithWhereUniqueWithoutUserInput {
  data: PunchCardUpdateWithoutUserDataInput!
  where: PunchCardWhereUniqueInput!
}

input PunchCardUpsertWithWhereUniqueWithoutTimeRoleInput {
  create: PunchCardCreateWithoutTimeRoleInput!
  update: PunchCardUpdateWithoutTimeRoleDataInput!
  where: PunchCardWhereUniqueInput!
}

input PunchCardUpsertWithWhereUniqueWithoutUserInput {
  create: PunchCardCreateWithoutUserInput!
  update: PunchCardUpdateWithoutUserDataInput!
  where: PunchCardWhereUniqueInput!
}

input PunchCardWhereInput {
  AND: [PunchCardWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [PunchCardWhereInput!]
  OR: [PunchCardWhereInput!]
  punchIn: DateTimeFilter
  punchOut: DateTimeFilter
  timeRole: TimeRoleWhereInput
  timeRoleId: StringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
  userID: StringFilter
}

input PunchCardWhereUniqueInput {
  id: String
}

type Query {
  me: User
  punchCard(where: PunchCardWhereUniqueInput!): PunchCard
  punchCards(after: PunchCardWhereUniqueInput, before: PunchCardWhereUniqueInput, first: Int, last: Int, orderBy: PunchCardOrderByInput, skip: Int, where: PunchCardWhereInput): [PunchCard!]!
  task(where: TaskWhereUniqueInput!): Task
  taskList(where: TaskListWhereUniqueInput!): TaskList
  taskLists(after: TaskListWhereUniqueInput, before: TaskListWhereUniqueInput, first: Int, last: Int, orderBy: TaskListOrderByInput, skip: Int, where: TaskListWhereInput): [TaskList!]!
  tasks(after: TaskWhereUniqueInput, before: TaskWhereUniqueInput, first: Int, last: Int, orderBy: TaskOrderByInput, skip: Int): [Task!]!
  test(where: UserWhereInput): [User!]!
  timeRequest(where: TimeRequestWhereUniqueInput!): TimeRequest
  timeRequests(after: TimeRequestWhereUniqueInput, before: TimeRequestWhereUniqueInput, first: Int, last: Int, orderBy: TimeRequestOrderByInput, skip: Int, where: TimeRequestWhereInput): [TimeRequest!]!
  timeRoles(after: TimeRoleWhereUniqueInput, before: TimeRoleWhereUniqueInput, first: Int, last: Int, orderBy: TimeRoleOrderByInput, skip: Int, where: TimeRoleWhereInput): [TimeRole!]!
  users(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int, orderBy: UserOrderByInput, skip: Int, where: UserWhereInput): [User!]!
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type Task {
  childrenTasks(after: TaskWhereUniqueInput, before: TaskWhereUniqueInput, first: Int, last: Int, skip: Int): [Task!]!
  createdAt: DateTime!
  id: String!
  name: String!
  orderRank: Float!
  parentTask: Task
  updatedAt: DateTime!
}

input TaskCreateInput {
  childrenTasks: TaskCreateManyWithoutParentTaskInput
  createdAt: DateTime
  id: String
  name: String!
  orderRank: Float!
  parentTask: TaskCreateOneWithoutChildrenTasksInput
  taskId: String
  TaskList: TaskListCreateOneWithoutTasksInput
  updatedAt: DateTime
}

input TaskCreateManyWithoutParentTaskInput {
  connect: [TaskWhereUniqueInput!]
  create: [TaskCreateWithoutParentTaskInput!]
}

input TaskCreateManyWithoutTaskListInput {
  connect: [TaskWhereUniqueInput!]
  create: [TaskCreateWithoutTaskListInput!]
}

input TaskCreateOneWithoutChildrenTasksInput {
  connect: TaskWhereUniqueInput
  create: TaskCreateWithoutChildrenTasksInput
}

input TaskCreateWithoutChildrenTasksInput {
  createdAt: DateTime
  id: String
  name: String!
  orderRank: Float!
  parentTask: TaskCreateOneWithoutChildrenTasksInput
  taskId: String
  TaskList: TaskListCreateOneWithoutTasksInput
  updatedAt: DateTime
}

input TaskCreateWithoutParentTaskInput {
  childrenTasks: TaskCreateManyWithoutParentTaskInput
  createdAt: DateTime
  id: String
  name: String!
  orderRank: Float!
  taskId: String
  TaskList: TaskListCreateOneWithoutTasksInput
  updatedAt: DateTime
}

input TaskCreateWithoutTaskListInput {
  childrenTasks: TaskCreateManyWithoutParentTaskInput
  createdAt: DateTime
  id: String
  name: String!
  orderRank: Float!
  parentTask: TaskCreateOneWithoutChildrenTasksInput
  taskId: String
  updatedAt: DateTime
}

input TaskFilter {
  every: TaskWhereInput
  none: TaskWhereInput
  some: TaskWhereInput
}

type TaskList {
  createdAt: DateTime!
  id: String!
  name: String!
  tasks(after: TaskWhereUniqueInput, before: TaskWhereUniqueInput, first: Int, last: Int, skip: Int): [Task!]!
  updatedAt: DateTime!
}

input TaskListCreateInput {
  createdAt: DateTime
  id: String
  name: String!
  tasks: TaskCreateManyWithoutTaskListInput
  updatedAt: DateTime
}

input TaskListCreateOneWithoutTasksInput {
  connect: TaskListWhereUniqueInput
  create: TaskListCreateWithoutTasksInput
}

input TaskListCreateWithoutTasksInput {
  createdAt: DateTime
  id: String
  name: String!
  updatedAt: DateTime
}

input TaskListOrderByInput {
  createdAt: OrderByArg
  id: OrderByArg
  name: OrderByArg
  updatedAt: OrderByArg
}

input TaskListUpdateInput {
  createdAt: DateTime
  id: String
  name: String
  tasks: TaskUpdateManyWithoutTaskListInput
  updatedAt: DateTime
}

input TaskListUpdateOneWithoutTasksInput {
  connect: TaskListWhereUniqueInput
  create: TaskListCreateWithoutTasksInput
  delete: Boolean
  disconnect: Boolean
  update: TaskListUpdateWithoutTasksDataInput
  upsert: TaskListUpsertWithoutTasksInput
}

input TaskListUpdateWithoutTasksDataInput {
  createdAt: DateTime
  id: String
  name: String
  updatedAt: DateTime
}

input TaskListUpsertWithoutTasksInput {
  create: TaskListCreateWithoutTasksInput!
  update: TaskListUpdateWithoutTasksDataInput!
}

input TaskListWhereInput {
  AND: [TaskListWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  name: StringFilter
  NOT: [TaskListWhereInput!]
  OR: [TaskListWhereInput!]
  tasks: TaskFilter
  updatedAt: DateTimeFilter
}

input TaskListWhereUniqueInput {
  id: String
}

input TaskOrderByInput {
  createdAt: OrderByArg
  id: OrderByArg
  name: OrderByArg
  orderRank: OrderByArg
  taskId: OrderByArg
  TaskList: OrderByArg
  taskListId: OrderByArg
  updatedAt: OrderByArg
}

input TaskScalarWhereInput {
  AND: [TaskScalarWhereInput!]
  childrenTasks: TaskFilter
  createdAt: DateTimeFilter
  id: StringFilter
  name: StringFilter
  NOT: [TaskScalarWhereInput!]
  OR: [TaskScalarWhereInput!]
  orderRank: FloatFilter
  taskId: NullableStringFilter
  taskListId: NullableStringFilter
  updatedAt: DateTimeFilter
}

input TaskUpdateInput {
  childrenTasks: TaskUpdateManyWithoutParentTaskInput
  createdAt: DateTime
  id: String
  name: String
  orderRank: Float
  parentTask: TaskUpdateOneWithoutChildrenTasksInput
  taskId: String
  TaskList: TaskListUpdateOneWithoutTasksInput
  updatedAt: DateTime
}

input TaskUpdateManyDataInput {
  createdAt: DateTime
  id: String
  name: String
  orderRank: Float
  taskId: String
  updatedAt: DateTime
}

input TaskUpdateManyWithoutParentTaskInput {
  connect: [TaskWhereUniqueInput!]
  create: [TaskCreateWithoutParentTaskInput!]
  delete: [TaskWhereUniqueInput!]
  deleteMany: [TaskScalarWhereInput!]
  disconnect: [TaskWhereUniqueInput!]
  set: [TaskWhereUniqueInput!]
  update: [TaskUpdateWithWhereUniqueWithoutParentTaskInput!]
  updateMany: [TaskUpdateManyWithWhereNestedInput!]
  upsert: [TaskUpsertWithWhereUniqueWithoutParentTaskInput!]
}

input TaskUpdateManyWithoutTaskListInput {
  connect: [TaskWhereUniqueInput!]
  create: [TaskCreateWithoutTaskListInput!]
  delete: [TaskWhereUniqueInput!]
  deleteMany: [TaskScalarWhereInput!]
  disconnect: [TaskWhereUniqueInput!]
  set: [TaskWhereUniqueInput!]
  update: [TaskUpdateWithWhereUniqueWithoutTaskListInput!]
  updateMany: [TaskUpdateManyWithWhereNestedInput!]
  upsert: [TaskUpsertWithWhereUniqueWithoutTaskListInput!]
}

input TaskUpdateManyWithWhereNestedInput {
  data: TaskUpdateManyDataInput!
  where: TaskScalarWhereInput!
}

input TaskUpdateOneWithoutChildrenTasksInput {
  connect: TaskWhereUniqueInput
  create: TaskCreateWithoutChildrenTasksInput
  delete: Boolean
  disconnect: Boolean
  update: TaskUpdateWithoutChildrenTasksDataInput
  upsert: TaskUpsertWithoutChildrenTasksInput
}

input TaskUpdateWithoutChildrenTasksDataInput {
  createdAt: DateTime
  id: String
  name: String
  orderRank: Float
  parentTask: TaskUpdateOneWithoutChildrenTasksInput
  taskId: String
  TaskList: TaskListUpdateOneWithoutTasksInput
  updatedAt: DateTime
}

input TaskUpdateWithoutParentTaskDataInput {
  childrenTasks: TaskUpdateManyWithoutParentTaskInput
  createdAt: DateTime
  id: String
  name: String
  orderRank: Float
  taskId: String
  TaskList: TaskListUpdateOneWithoutTasksInput
  updatedAt: DateTime
}

input TaskUpdateWithoutTaskListDataInput {
  childrenTasks: TaskUpdateManyWithoutParentTaskInput
  createdAt: DateTime
  id: String
  name: String
  orderRank: Float
  parentTask: TaskUpdateOneWithoutChildrenTasksInput
  taskId: String
  updatedAt: DateTime
}

input TaskUpdateWithWhereUniqueWithoutParentTaskInput {
  data: TaskUpdateWithoutParentTaskDataInput!
  where: TaskWhereUniqueInput!
}

input TaskUpdateWithWhereUniqueWithoutTaskListInput {
  data: TaskUpdateWithoutTaskListDataInput!
  where: TaskWhereUniqueInput!
}

input TaskUpsertWithoutChildrenTasksInput {
  create: TaskCreateWithoutChildrenTasksInput!
  update: TaskUpdateWithoutChildrenTasksDataInput!
}

input TaskUpsertWithWhereUniqueWithoutParentTaskInput {
  create: TaskCreateWithoutParentTaskInput!
  update: TaskUpdateWithoutParentTaskDataInput!
  where: TaskWhereUniqueInput!
}

input TaskUpsertWithWhereUniqueWithoutTaskListInput {
  create: TaskCreateWithoutTaskListInput!
  update: TaskUpdateWithoutTaskListDataInput!
  where: TaskWhereUniqueInput!
}

input TaskWhereInput {
  AND: [TaskWhereInput!]
  childrenTasks: TaskFilter
  createdAt: DateTimeFilter
  id: StringFilter
  name: StringFilter
  NOT: [TaskWhereInput!]
  OR: [TaskWhereInput!]
  orderRank: FloatFilter
  parentTask: TaskWhereInput
  taskId: NullableStringFilter
  TaskList: TaskListWhereInput
  taskListId: NullableStringFilter
  updatedAt: DateTimeFilter
}

input TaskWhereUniqueInput {
  id: String
}

type TimeRequest {
  approved: Boolean
  createdAt: DateTime!
  endTime: DateTime!
  id: String!
  isAllDay: Boolean!
  reason: String!
  startTime: DateTime!
  updatedAt: DateTime!
  user: User!
}

input TimeRequestCreateInput {
  approved: Boolean
  createdAt: DateTime
  endTime: DateTime!
  id: String
  isAllDay: Boolean
  reason: String!
  startTime: DateTime!
  updatedAt: DateTime
  user: UserCreateOneWithoutEventsInput!
}

input TimeRequestCreateManyWithoutUserInput {
  connect: [TimeRequestWhereUniqueInput!]
  create: [TimeRequestCreateWithoutUserInput!]
}

input TimeRequestCreateWithoutUserInput {
  approved: Boolean
  createdAt: DateTime
  endTime: DateTime!
  id: String
  isAllDay: Boolean
  reason: String!
  startTime: DateTime!
  updatedAt: DateTime
}

input TimeRequestFilter {
  every: TimeRequestWhereInput
  none: TimeRequestWhereInput
  some: TimeRequestWhereInput
}

input TimeRequestOrderByInput {
  approved: OrderByArg
  createdAt: OrderByArg
  endTime: OrderByArg
  id: OrderByArg
  isAllDay: OrderByArg
  reason: OrderByArg
  startTime: OrderByArg
  updatedAt: OrderByArg
  user: OrderByArg
  userId: OrderByArg
}

input TimeRequestScalarWhereInput {
  AND: [TimeRequestScalarWhereInput!]
  approved: NullableBooleanFilter
  createdAt: DateTimeFilter
  endTime: DateTimeFilter
  id: StringFilter
  isAllDay: BooleanFilter
  NOT: [TimeRequestScalarWhereInput!]
  OR: [TimeRequestScalarWhereInput!]
  reason: StringFilter
  startTime: DateTimeFilter
  updatedAt: DateTimeFilter
  userId: StringFilter
}

input TimeRequestUpdateInput {
  approved: Boolean
  createdAt: DateTime
  endTime: DateTime
  id: String
  isAllDay: Boolean
  reason: String
  startTime: DateTime
  updatedAt: DateTime
  user: UserUpdateOneRequiredWithoutEventsInput
}

input TimeRequestUpdateManyDataInput {
  approved: Boolean
  createdAt: DateTime
  endTime: DateTime
  id: String
  isAllDay: Boolean
  reason: String
  startTime: DateTime
  updatedAt: DateTime
}

input TimeRequestUpdateManyWithoutUserInput {
  connect: [TimeRequestWhereUniqueInput!]
  create: [TimeRequestCreateWithoutUserInput!]
  delete: [TimeRequestWhereUniqueInput!]
  deleteMany: [TimeRequestScalarWhereInput!]
  disconnect: [TimeRequestWhereUniqueInput!]
  set: [TimeRequestWhereUniqueInput!]
  update: [TimeRequestUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [TimeRequestUpdateManyWithWhereNestedInput!]
  upsert: [TimeRequestUpsertWithWhereUniqueWithoutUserInput!]
}

input TimeRequestUpdateManyWithWhereNestedInput {
  data: TimeRequestUpdateManyDataInput!
  where: TimeRequestScalarWhereInput!
}

input TimeRequestUpdateWithoutUserDataInput {
  approved: Boolean
  createdAt: DateTime
  endTime: DateTime
  id: String
  isAllDay: Boolean
  reason: String
  startTime: DateTime
  updatedAt: DateTime
}

input TimeRequestUpdateWithWhereUniqueWithoutUserInput {
  data: TimeRequestUpdateWithoutUserDataInput!
  where: TimeRequestWhereUniqueInput!
}

input TimeRequestUpsertWithWhereUniqueWithoutUserInput {
  create: TimeRequestCreateWithoutUserInput!
  update: TimeRequestUpdateWithoutUserDataInput!
  where: TimeRequestWhereUniqueInput!
}

input TimeRequestWhereInput {
  AND: [TimeRequestWhereInput!]
  approved: NullableBooleanFilter
  createdAt: DateTimeFilter
  endTime: DateTimeFilter
  id: StringFilter
  isAllDay: BooleanFilter
  NOT: [TimeRequestWhereInput!]
  OR: [TimeRequestWhereInput!]
  reason: StringFilter
  startTime: DateTimeFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input TimeRequestWhereUniqueInput {
  id: String
}

type TimeRole {
  createdAt: DateTime!
  description: String!
  id: String!
  name: String!
  payRate: Int!
  shortName: String!
  updatedAt: DateTime!
  users(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int, skip: Int): [User!]!
}

input TimeRoleCreateInput {
  createdAt: DateTime
  description: String!
  id: String
  name: String!
  payRate: Int!
  punchCards: PunchCardCreateManyWithoutTimeRoleInput
  shortName: String!
  updatedAt: DateTime
  users: UserCreateManyWithoutTimeRolesInput
}

input TimeRoleCreateManyWithoutUsersInput {
  connect: [TimeRoleWhereUniqueInput!]
  create: [TimeRoleCreateWithoutUsersInput!]
}

input TimeRoleCreateOneWithoutPunchCardsInput {
  connect: TimeRoleWhereUniqueInput
  create: TimeRoleCreateWithoutPunchCardsInput
}

input TimeRoleCreateWithoutPunchCardsInput {
  createdAt: DateTime
  description: String!
  id: String
  name: String!
  payRate: Int!
  shortName: String!
  updatedAt: DateTime
  users: UserCreateManyWithoutTimeRolesInput
}

input TimeRoleCreateWithoutUsersInput {
  createdAt: DateTime
  description: String!
  id: String
  name: String!
  payRate: Int!
  punchCards: PunchCardCreateManyWithoutTimeRoleInput
  shortName: String!
  updatedAt: DateTime
}

input TimeRoleFilter {
  every: TimeRoleWhereInput
  none: TimeRoleWhereInput
  some: TimeRoleWhereInput
}

input TimeRoleOrderByInput {
  createdAt: OrderByArg
  description: OrderByArg
  id: OrderByArg
  name: OrderByArg
  payRate: OrderByArg
  shortName: OrderByArg
  updatedAt: OrderByArg
}

input TimeRoleScalarWhereInput {
  AND: [TimeRoleScalarWhereInput!]
  createdAt: DateTimeFilter
  description: StringFilter
  id: StringFilter
  name: StringFilter
  NOT: [TimeRoleScalarWhereInput!]
  OR: [TimeRoleScalarWhereInput!]
  payRate: IntFilter
  punchCards: PunchCardFilter
  shortName: StringFilter
  updatedAt: DateTimeFilter
  users: UserFilter
}

input TimeRoleUpdateInput {
  createdAt: DateTime
  description: String
  id: String
  name: String
  payRate: Int
  punchCards: PunchCardUpdateManyWithoutTimeRoleInput
  shortName: String
  updatedAt: DateTime
  users: UserUpdateManyWithoutTimeRolesInput
}

input TimeRoleUpdateManyDataInput {
  createdAt: DateTime
  description: String
  id: String
  name: String
  payRate: Int
  shortName: String
  updatedAt: DateTime
}

input TimeRoleUpdateManyWithoutUsersInput {
  connect: [TimeRoleWhereUniqueInput!]
  create: [TimeRoleCreateWithoutUsersInput!]
  delete: [TimeRoleWhereUniqueInput!]
  deleteMany: [TimeRoleScalarWhereInput!]
  disconnect: [TimeRoleWhereUniqueInput!]
  set: [TimeRoleWhereUniqueInput!]
  update: [TimeRoleUpdateWithWhereUniqueWithoutUsersInput!]
  updateMany: [TimeRoleUpdateManyWithWhereNestedInput!]
  upsert: [TimeRoleUpsertWithWhereUniqueWithoutUsersInput!]
}

input TimeRoleUpdateManyWithWhereNestedInput {
  data: TimeRoleUpdateManyDataInput!
  where: TimeRoleScalarWhereInput!
}

input TimeRoleUpdateOneRequiredWithoutPunchCardsInput {
  connect: TimeRoleWhereUniqueInput
  create: TimeRoleCreateWithoutPunchCardsInput
  update: TimeRoleUpdateWithoutPunchCardsDataInput
  upsert: TimeRoleUpsertWithoutPunchCardsInput
}

input TimeRoleUpdateWithoutPunchCardsDataInput {
  createdAt: DateTime
  description: String
  id: String
  name: String
  payRate: Int
  shortName: String
  updatedAt: DateTime
  users: UserUpdateManyWithoutTimeRolesInput
}

input TimeRoleUpdateWithoutUsersDataInput {
  createdAt: DateTime
  description: String
  id: String
  name: String
  payRate: Int
  punchCards: PunchCardUpdateManyWithoutTimeRoleInput
  shortName: String
  updatedAt: DateTime
}

input TimeRoleUpdateWithWhereUniqueWithoutUsersInput {
  data: TimeRoleUpdateWithoutUsersDataInput!
  where: TimeRoleWhereUniqueInput!
}

input TimeRoleUpsertWithoutPunchCardsInput {
  create: TimeRoleCreateWithoutPunchCardsInput!
  update: TimeRoleUpdateWithoutPunchCardsDataInput!
}

input TimeRoleUpsertWithWhereUniqueWithoutUsersInput {
  create: TimeRoleCreateWithoutUsersInput!
  update: TimeRoleUpdateWithoutUsersDataInput!
  where: TimeRoleWhereUniqueInput!
}

input TimeRoleWhereInput {
  AND: [TimeRoleWhereInput!]
  createdAt: DateTimeFilter
  description: StringFilter
  id: StringFilter
  name: StringFilter
  NOT: [TimeRoleWhereInput!]
  OR: [TimeRoleWhereInput!]
  payRate: IntFilter
  punchCards: PunchCardFilter
  shortName: StringFilter
  updatedAt: DateTimeFilter
  users: UserFilter
}

input TimeRoleWhereUniqueInput {
  id: String
}

type User {
  clockedIn: String!
  code: Int!
  createdAt: DateTime!
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  permissions: [Permission!]!
  recentTimeRoleId: String!
  timeRoles(after: TimeRoleWhereUniqueInput, before: TimeRoleWhereUniqueInput, first: Int, last: Int, skip: Int): [TimeRole!]!
  title: String
  updatedAt: DateTime!
}

input UserCreateManyWithoutTimeRolesInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutTimeRolesInput!]
}

input UserCreateOneWithoutEventsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutEventsInput
}

input UserCreateOneWithoutPunchCardsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutPunchCardsInput
}

input UserCreatepermissionsInput {
  set: [Permission!]
}

input UserCreateWithoutEventsInput {
  code: Int!
  createdAt: DateTime
  email: String!
  firstName: String!
  id: String
  lastName: String!
  password: String!
  permissions: UserCreatepermissionsInput
  punchCards: PunchCardCreateManyWithoutUserInput
  timeRoles: TimeRoleCreateManyWithoutUsersInput
  title: String
  updatedAt: DateTime
}

input UserCreateWithoutPunchCardsInput {
  code: Int!
  createdAt: DateTime
  email: String!
  events: TimeRequestCreateManyWithoutUserInput
  firstName: String!
  id: String
  lastName: String!
  password: String!
  permissions: UserCreatepermissionsInput
  timeRoles: TimeRoleCreateManyWithoutUsersInput
  title: String
  updatedAt: DateTime
}

input UserCreateWithoutTimeRolesInput {
  code: Int!
  createdAt: DateTime
  email: String!
  events: TimeRequestCreateManyWithoutUserInput
  firstName: String!
  id: String
  lastName: String!
  password: String!
  permissions: UserCreatepermissionsInput
  punchCards: PunchCardCreateManyWithoutUserInput
  title: String
  updatedAt: DateTime
}

input UserFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

input UserOrderByInput {
  code: OrderByArg
  createdAt: OrderByArg
  email: OrderByArg
  firstName: OrderByArg
  id: OrderByArg
  lastName: OrderByArg
  password: OrderByArg
  title: OrderByArg
  updatedAt: OrderByArg
}

input UserScalarWhereInput {
  AND: [UserScalarWhereInput!]
  code: IntFilter
  createdAt: DateTimeFilter
  email: StringFilter
  events: TimeRequestFilter
  firstName: StringFilter
  id: StringFilter
  lastName: StringFilter
  NOT: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  password: StringFilter
  punchCards: PunchCardFilter
  timeRoles: TimeRoleFilter
  title: NullableStringFilter
  updatedAt: DateTimeFilter
}

input UserUpdateInput {
  code: Int
  createdAt: DateTime
  email: String
  events: TimeRequestUpdateManyWithoutUserInput
  firstName: String
  id: String
  lastName: String
  password: String
  permissions: UserUpdatepermissionsInput
  punchCards: PunchCardUpdateManyWithoutUserInput
  timeRoles: TimeRoleUpdateManyWithoutUsersInput
  title: String
  updatedAt: DateTime
}

input UserUpdateManyDataInput {
  code: Int
  createdAt: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  permissions: UserUpdatepermissionsInput
  title: String
  updatedAt: DateTime
}

input UserUpdateManyWithoutTimeRolesInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutTimeRolesInput!]
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutTimeRolesInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutTimeRolesInput!]
}

input UserUpdateManyWithWhereNestedInput {
  data: UserUpdateManyDataInput!
  where: UserScalarWhereInput!
}

input UserUpdateOneRequiredWithoutEventsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutEventsInput
  update: UserUpdateWithoutEventsDataInput
  upsert: UserUpsertWithoutEventsInput
}

input UserUpdateOneRequiredWithoutPunchCardsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutPunchCardsInput
  update: UserUpdateWithoutPunchCardsDataInput
  upsert: UserUpsertWithoutPunchCardsInput
}

input UserUpdatepermissionsInput {
  set: [Permission!]
}

input UserUpdateWithoutEventsDataInput {
  code: Int
  createdAt: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  permissions: UserUpdatepermissionsInput
  punchCards: PunchCardUpdateManyWithoutUserInput
  timeRoles: TimeRoleUpdateManyWithoutUsersInput
  title: String
  updatedAt: DateTime
}

input UserUpdateWithoutPunchCardsDataInput {
  code: Int
  createdAt: DateTime
  email: String
  events: TimeRequestUpdateManyWithoutUserInput
  firstName: String
  id: String
  lastName: String
  password: String
  permissions: UserUpdatepermissionsInput
  timeRoles: TimeRoleUpdateManyWithoutUsersInput
  title: String
  updatedAt: DateTime
}

input UserUpdateWithoutTimeRolesDataInput {
  code: Int
  createdAt: DateTime
  email: String
  events: TimeRequestUpdateManyWithoutUserInput
  firstName: String
  id: String
  lastName: String
  password: String
  permissions: UserUpdatepermissionsInput
  punchCards: PunchCardUpdateManyWithoutUserInput
  title: String
  updatedAt: DateTime
}

input UserUpdateWithWhereUniqueWithoutTimeRolesInput {
  data: UserUpdateWithoutTimeRolesDataInput!
  where: UserWhereUniqueInput!
}

input UserUpsertWithoutEventsInput {
  create: UserCreateWithoutEventsInput!
  update: UserUpdateWithoutEventsDataInput!
}

input UserUpsertWithoutPunchCardsInput {
  create: UserCreateWithoutPunchCardsInput!
  update: UserUpdateWithoutPunchCardsDataInput!
}

input UserUpsertWithWhereUniqueWithoutTimeRolesInput {
  create: UserCreateWithoutTimeRolesInput!
  update: UserUpdateWithoutTimeRolesDataInput!
  where: UserWhereUniqueInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  code: IntFilter
  createdAt: DateTimeFilter
  email: StringFilter
  events: TimeRequestFilter
  firstName: StringFilter
  id: StringFilter
  lastName: StringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: StringFilter
  punchCards: PunchCardFilter
  timeRoles: TimeRoleFilter
  title: NullableStringFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  code: Int
  email: String
  id: String
}
